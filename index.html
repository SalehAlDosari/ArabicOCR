<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>OCR Ø¹Ø±Ø¨ÙŠ Ø¨Ø®Ø·Ù‘Ùƒ + ØµÙˆØªÙƒ</title>

  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

  <style>
    :root {
      color-scheme: dark;
      --bg: #0f172a;
      --panel: #1e293b;
      --accent: #06b6d4;
      --accent-glow: rgba(6,182,212,0.3);
      --accent-soft: rgba(6,182,212,0.15);
      --secondary: #8b5cf6;
      --danger: #ef4444;
      --good: #10b981;
      --warning: #f59e0b;
      --ink: #f1f5f9;
      --muted: #94a3b8;
      --border: rgba(100,116,139,0.3);
      --shadow: rgba(0,0,0,0.5);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      background:
        radial-gradient(ellipse at top, rgba(6,182,212,0.15), transparent 50%),
        radial-gradient(ellipse at bottom right, rgba(139,92,246,0.1), transparent 50%),
        linear-gradient(180deg, #0f172a 0%, #1e293b 100%);
      color: var(--ink);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background:
        repeating-linear-gradient(
          90deg,
          rgba(6,182,212,0.03) 0px,
          transparent 1px,
          transparent 80px,
          rgba(6,182,212,0.03) 81px
        ),
        repeating-linear-gradient(
          0deg,
          rgba(6,182,212,0.03) 0px,
          transparent 1px,
          transparent 80px,
          rgba(6,182,212,0.03) 81px
        );
      pointer-events: none;
      z-index: 0;
    }

    .app {
      width: min(950px, 100%);
      background: rgba(30,41,59,0.85);
      border-radius: 28px;
      border: 1px solid var(--border);
      padding: 24px;
      box-shadow:
        0 20px 60px var(--shadow),
        0 0 0 1px rgba(6,182,212,0.1) inset,
        0 0 40px rgba(6,182,212,0.05);
      backdrop-filter: blur(20px);
      position: relative;
      z-index: 1;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .title {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .title h1 {
      margin: 0;
      font-size: 1.08rem;
      font-weight: 700;
      letter-spacing: 0.02em;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .chip {
      padding: 3px 10px;
      border-radius: 999px;
      font-size: 0.62rem;
      font-weight: 600;
      border: 1px solid rgba(6,182,212,0.4);
      color: var(--accent);
      background: rgba(6,182,212,0.1);
      box-shadow: 0 0 12px rgba(6,182,212,0.2);
      animation: pulse 3s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 12px rgba(6,182,212,0.2); }
      50% { box-shadow: 0 0 20px rgba(6,182,212,0.4); }
    }

    .title p {
      margin: 0;
      font-size: 0.66rem;
      color: var(--muted);
    }

    .status {
      font-size: 0.62rem;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 5px;
      white-space: nowrap;
    }

    .layout {
      display: grid;
      grid-template-columns: 2.1fr 1.4fr;
      gap: 12px;
    }

    @media (max-width: 720px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      padding: 10px;
      border-radius: 18px;
      border: 1px solid rgba(148,163,253,0.18);
      background: radial-gradient(circle at top, rgba(15,23,42,0.96), #020817);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .panel h2 {
      margin: 0;
      font-size: 0.72rem;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .panel h2 span {
      color: var(--accent);
      font-size: 0.74rem;
    }

    .cam-box {
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid rgba(56,189,248,0.16);
      background: radial-gradient(circle at top, rgba(15,23,42,0.92), #020817);
      min-height: 210px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    video, img.preview {
      max-width: 100%;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #020817;
    }

    .hint {
      position: absolute;
      bottom: 6px;
      left: 8px;
      right: 8px;
      font-size: 0.56rem;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 4px;
      opacity: 0.9;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      justify-content: flex-start;
    }

    button, label.btn {
      border: none;
      outline: none;
      padding: 8px 16px;
      border-radius: 10px;
      font-size: 0.7rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: linear-gradient(135deg, var(--accent), #0891b2);
      color: white;
      border: 1px solid rgba(6,182,212,0.5);
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 12px rgba(6,182,212,0.3);
      position: relative;
      overflow: hidden;
    }

    button::before, label.btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      transition: left 0.5s;
    }

    button:hover::before, label.btn:hover::before {
      left: 100%;
    }

    button:hover, label.btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(6,182,212,0.5);
    }

    button:active, label.btn:active {
      transform: translateY(0);
    }

    button.secondary {
      background: rgba(139,92,246,0.1);
      color: var(--secondary);
      border: 1px solid rgba(139,92,246,0.4);
      box-shadow: 0 4px 12px rgba(139,92,246,0.2);
    }

    button.secondary:hover {
      background: linear-gradient(135deg, var(--secondary), #7c3aed);
      color: white;
      box-shadow: 0 6px 20px rgba(139,92,246,0.5);
    }

    input[type="file"] {
      display: none;
    }

    .result-box {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 4px;
    }

    .result-char {
      font-size: 3rem;
      font-weight: 700;
      color: var(--accent);
      padding: 16px 24px;
      border-radius: 18px;
      border: 2px solid rgba(6,182,212,0.5);
      background:
        linear-gradient(135deg, rgba(6,182,212,0.1), rgba(139,92,246,0.1)),
        rgba(30,41,59,0.8);
      display: inline-flex;
      align-items: center;
      gap: 12px;
      min-height: 80px;
      box-shadow:
        0 10px 30px rgba(6,182,212,0.3),
        0 0 0 1px rgba(6,182,212,0.1) inset;
      transition: all 0.3s ease;
    }

    .result-char:hover {
      transform: scale(1.02);
      box-shadow:
        0 15px 40px rgba(6,182,212,0.4),
        0 0 0 1px rgba(6,182,212,0.2) inset;
    }

    .result-char small {
      font-size: 0.56rem;
      color: var(--muted);
      font-weight: 400;
    }

    .error {
      font-size: 0.58rem;
      color: var(--danger);
      min-height: 12px;
    }

    .steps {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.6rem;
      color: var(--muted);
    }

    .steps b {
      color: var(--accent);
      font-weight: 600;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(56,189,248,0.3);
      font-size: 0.56rem;
      color: var(--muted);
    }

    .footer {
      margin-top: 8px;
      font-size: 0.5rem;
      color: #6b7280;
      text-align: center;
    }

    .footer span {
      color: var(--accent);
    }
  </style>
</head>
<body>
<div class="app">
  <div class="header">
    <div class="title">
      <h1>ğŸ¯ OCR Ø¹Ø±Ø¨ÙŠ Ø¨Ø®Ø·Ù‘Ùƒ Ø§Ù„Ù…Ø®ØµØµ <span class="chip">AI-Powered Recognition</span></h1>
      <p>Ù†Ø¸Ø§Ù… Ø°ÙƒÙŠ Ù„Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø­Ø±Ù Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø¨Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ© - Ù…ÙØ¯Ø±Ø¨ Ø®ØµÙŠØµÙ‹Ø§ Ø¹Ù„Ù‰ Ø®Ø·Ùƒ</p>
    </div>
    <div class="status">
      <div id="statusDot" style="width:8px;height:8px;border-radius:999px;background:#f97316;box-shadow:0 0 10px #f97316;"></div>
      <span id="status">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬...</span>
    </div>
  </div>

  <div class="layout">
    <!-- LEFT: camera / upload -->
    <div class="panel">
      <h2><span>â‘ </span> Ø§Ù„ØªÙ‚Ø· Ø­Ø±ÙÙ‹Ø§ ÙˆØ§Ø­Ø¯Ù‹Ø§ Ø¨Ø®Ø·Ùƒ</h2>
      <div class="cam-box" id="camBox">
        <video id="video" autoplay playsinline muted style="display:none;"></video>
        <img id="uploadPreview" class="preview" alt="" style="display:none;" />
        <div id="overlayText" class="hint">
          <div>Ø¶Ø¹ <b>Ø­Ø±ÙÙ‹Ø§ ÙˆØ§Ø­Ø¯Ù‹Ø§ ÙƒØ¨ÙŠØ±Ù‹Ø§</b> ÙÙŠ Ù…Ù†ØªØµÙ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ØŒ Ø®Ù„ÙÙŠØ© Ø¨ÙŠØ¶Ø§Ø¡ØŒ Ø¨Ø¯ÙˆÙ† Ø¸Ù„.</div>
          <div>Android / iOS Ù…Ø¯Ø¹ÙˆÙ….</div>
        </div>
      </div>

      <div class="btn-row" style="margin-top:6px;">
        <button id="startCamBtn">ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</button>
        <button id="captureBtn">Ø§Ù„ØªÙ‚Ø§Ø· &amp; ØªØ¹Ø±Ù‘Ù</button>
        <label class="btn secondary" for="fileInput">ğŸ“ Ø§Ø®ØªÙŠØ§Ø± ØµÙˆØ±Ø© Ù…Ù† Ø§Ù„Ù…Ø¹Ø±Ø¶</label>
        <input id="fileInput" type="file" accept="image/*" capture="environment" />
        <button id="resetViewBtn" class="secondary">â†º Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¶Ø¨Ø·</button>
      </div>
    </div>

    <!-- RIGHT: result -->
    <div class="panel">
      <h2><span>â‘¡</span> Ø§Ù„Ù†ØªÙŠØ¬Ø© + Ø§Ù„ØµÙˆØª</h2>
      <div class="result-box">
        <div class="result-char" id="resultBox">
          <span id="resultChar">-</span>
          <small id="confText"></small>
        </div>
        <div class="btn-row">
          <button id="playVoiceBtn">ğŸ”Š Ù†Ø·Ù‚ Ø§Ù„Ø­Ø±Ù</button>
          <button id="copyBtn" class="secondary">ğŸ“‹ Ù†Ø³Ø®</button>
        </div>
        <div id="errorBox" class="error"></div>

        <!-- Debug: what the model actually sees -->
        <div style="display:flex;align-items:flex-start;gap:8px;margin-top:4px;">
          <canvas id="debug64" width="64" height="64"
                  style="border:1px solid rgba(148,163,253,0.35);
                         border-radius:6px;
                         background:#111827;
                         image-rendering:pixelated;">
          </canvas>
          <div style="font-size:0.55rem;color:#6b7280;">
            Ù‡Ø°Ù‡ Ù‡ÙŠ ØµÙˆØ±Ø© 64Ã—64 Ø§Ù„ØªÙŠ ÙŠØ±Ø§Ù‡Ø§ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬.<br>
            ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø­Ø±Ù Ø£Ø³ÙˆØ¯ ÙˆØ§Ø¶Ø­ ÙÙŠ Ø§Ù„Ù…Ù†ØªØµÙ Ø¹Ù„Ù‰ Ø®Ù„ÙÙŠØ© Ø¨ÙŠØ¶Ø§Ø¡.
          </div>
        </div>
      </div>

      <div class="steps">
        <div class="pill">âœ” ÙŠØ¹ØªÙ…Ø¯ ÙÙ‚Ø· Ø¹Ù„Ù‰ Ø®Ø·Ù‘Ùƒ (font.ttf) + Ù†Ù…ÙˆØ°Ø¬ CNN Ù…Ø¯Ø±Ù‘ÙØ¨.</div>
        <div>1. Ø§Ø·Ø¨Ø¹ Ø£Ùˆ Ø§ÙƒØªØ¨ Ø­Ø±ÙÙ‹Ø§ ÙˆØ§Ø­Ø¯Ù‹Ø§ Ù…Ù†ÙØµÙ„Ù‹Ø§ ÙˆÙˆØ§Ø¶Ø­Ù‹Ø§.</div>
        <div>2. Ø§Ø¬Ø¹Ù„ Ø§Ù„Ø­Ø±Ù ÙƒØ¨ÙŠØ±Ù‹Ø§ ÙÙŠ Ù…Ù†ØªØµÙ Ø§Ù„ÙƒØ§Ø¯Ø±ØŒ ÙˆØ§Ù„Ù‡Ø§ØªÙ ÙÙˆÙ‚ Ø§Ù„ÙˆØ±Ù‚Ø© Ø¨Ø´ÙƒÙ„ Ù…Ø³ØªÙ‚ÙŠÙ….</div>
        <div>3. Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø­Ø±Ù ÙˆØ§Ø¶Ø­ØŒ Ø³ØªØ¸Ù‡Ø± Ø±Ø³Ø§Ù„Ø© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ù†ØªÙŠØ¬Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©.</div>
      </div>
    </div>
  </div>

  <div class="footer">
    ğŸ”’ ÙŠØ¹Ù…Ù„ Ù…Ø­Ù„ÙŠÙ‹Ø§ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ - Ù„Ø§ ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ø¥Ù„Ù‰ Ø£ÙŠ Ù…ÙƒØ§Ù† | <span>Ù…ÙØ¯Ø±Ø¨ Ø¨ØªÙ‚Ù†ÙŠØ© Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø¹Ù…ÙŠÙ‚</span>
  </div>
</div>

<canvas id="hiddenCanvas" width="64" height="64" style="display:none;"></canvas>

<script>
  let session = null;
  let labels = {};
  let videoStream = null;
  let lastChar = null;
  let audioEl = new Audio();

  const charAudio = {
    "Ø¡": "audio/Ø¡.mp3",
    "Ø¢": "audio/Ø¢.mp3",
    "Ø£": "audio/Ø£.mp3",
    "Ø¤": "audio/Ø¤.mp3",
    "Ø¥": "audio/Ø¥.mp3",
    "Ø¦": "audio/Ø¦.mp3",
    "Ø§": "audio/Ø§.mp3",
    "Ø¨": "audio/Ø¨.mp3",
    "Ø©": "audio/Ø©.mp3",
    "Øª": "audio/Øª.mp3",
    "Ø«": "audio/Ø«.mp3",
    "Ø¬": "audio/Ø¬.mp3",
    "Ø­": "audio/Ø­.mp3",
    "Ø®": "audio/Ø®.mp3",
    "Ø¯": "audio/Ø¯.mp3",
    "Ø°": "audio/Ø°.mp3",
    "Ø±": "audio/Ø±.mp3",
    "Ø²": "audio/Ø².mp3",
    "Ø³": "audio/Ø³.mp3",
    "Ø´": "audio/Ø´.mp3",
    "Øµ": "audio/Øµ.mp3",
    "Ø¶": "audio/Ø¶.mp3",
    "Ø·": "audio/Ø·.mp3",
    "Ø¸": "audio/Ø¸.mp3",
    "Ø¹": "audio/Ø¹.mp3",
    "Øº": "audio/Øº.mp3",
    "Ù": "audio/Ù.mp3",
    "Ù‚": "audio/Ù‚.mp3",
    "Ùƒ": "audio/Ùƒ.mp3",
    "Ù„": "audio/Ù„.mp3",
    "Ù„Ø§": "audio/Ù„Ø§.mp3",
    "Ù…": "audio/Ù….mp3",
    "Ù†": "audio/Ù†.mp3",
    "Ù‡": "audio/Ù‡.mp3",
    "Ùˆ": "audio/Ùˆ.mp3",
    "Ù‰": "audio/Ù‰.mp3",
    "ÙŠ": "audio/ÙŠ.mp3"
  };

  async function loadModel() {
    const status = document.getElementById("status");
    const dot = document.getElementById("statusDot");

    try {
      const labelsRes = await fetch("labels.json", { cache: "no-cache" });
      if (!labelsRes.ok) throw new Error("labels.json HTTP " + labelsRes.status);
      labels = await labelsRes.json();
      console.log("âœ… labels loaded:", labels);

      if (!window.ort) {
        throw new Error("onnxruntime-web (ort) not loaded. Check script tag.");
      }

      if (ort.env && ort.env.wasm) {
        ort.env.wasm.wasmPaths = "https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/";
        // Increase memory limit for larger models (16.6 MB model needs ~512MB WASM memory)
        ort.env.wasm.numThreads = 1;
        ort.env.wasm.simd = true;
      }

      // Set execution provider options with memory limit
      const sessionOptions = {
        executionProviders: [
          {
            name: 'wasm',
            deviceType: 'cpu',
            preferredLayout: 'NCHW'
          }
        ],
        graphOptimizationLevel: 'all',
        executionMode: 'sequential',
        enableMemPattern: false,  // Disable memory pattern to reduce memory usage
        enableCpuMemArena: false  // Disable CPU memory arena to reduce memory usage
      };

const MODEL_VERSION = "Custom Trained - 60 Epochs";
console.log("Loading model:", MODEL_VERSION);
status.textContent = "Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ (16.6 MB)...";

// Try to load model with error handling and retry
let modelPath = "arabic_char_cnn_v3.onnx";
try {
  status.textContent = "ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬... ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±";
  session = await ort.InferenceSession.create(modelPath + "?v=" + Date.now(), sessionOptions);
} catch (firstError) {
  console.warn("First attempt failed, trying without cache bust:", firstError);
  try {
    session = await ort.InferenceSession.create(modelPath, sessionOptions);
  } catch (secondError) {
    throw new Error("Failed to load model: " + secondError.message);
  }
}



      console.log("âœ… ONNX model loaded");
      status.textContent = "Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø¬Ø§Ù‡Ø² âœ…";
      dot.style.background = "#10b981";
      dot.style.boxShadow = "0 0 15px #10b981, 0 0 30px rgba(16,185,129,0.3)";
    } catch (err) {
      console.error("âŒ Model load error:", err);
      status.textContent = "Ø®Ø·Ø£: " + (err.message || err);
      dot.style.background = "#ef4444";
      dot.style.boxShadow = "0 0 15px #ef4444, 0 0 30px rgba(239,68,68,0.3)";
    }
  }

  async function startCamera() {
    const video = document.getElementById("video");
    const preview = document.getElementById("uploadPreview");
    const overlay = document.getElementById("overlayText");
    const errorBox = document.getElementById("errorBox");
    errorBox.textContent = "";

    try {
      if (videoStream) return;
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment" },
        audio: false
      });
      video.srcObject = stream;
      videoStream = stream;
      video.style.display = "block";
      preview.style.display = "none";
      overlay.style.opacity = "0.85";
    } catch (err) {
      console.error(err);
      errorBox.textContent =
        "Ù„Ø§ ÙŠÙ…ÙƒÙ† ÙØªØ­ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§. Ø§Ø³ØªØ®Ø¯Ù… Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ø£Ùˆ ÙØ¹Ù‘Ù„ Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª / HTTPS Ø¹Ù„Ù‰ Ø§Ù„Ø¬ÙˆØ§Ù„.";
    }
  }

  function stopCamera() {
    if (videoStream) {
      videoStream.getTracks().forEach(t => t.stop());
      videoStream = null;
    }
  }

  function resetView() {
    stopCamera();
    const video = document.getElementById("video");
    const preview = document.getElementById("uploadPreview");
    const overlay = document.getElementById("overlayText");
    video.style.display = "none";
    preview.style.display = "none";
    overlay.style.opacity = "1";
    preview.src = "";
    document.getElementById("resultChar").textContent = "-";
    document.getElementById("confText").textContent = "";
    document.getElementById("errorBox").textContent = "";
    lastChar = null;

    const debug64 = document.getElementById("debug64");
    if (debug64) {
      const dbgCtx = debug64.getContext("2d");
      dbgCtx.clearRect(0, 0, 64, 64);
    }
  }

  function setPreviewImage(src) {
    const video = document.getElementById("video");
    const preview = document.getElementById("uploadPreview");
    const overlay = document.getElementById("overlayText");
    stopCamera();
    video.style.display = "none";
    preview.style.display = "block";
    preview.src = src;
    overlay.style.opacity = "0.85";
  }

function getCurrentFrameAs64Gray() {
  const video = document.getElementById("video");
  const preview = document.getElementById("uploadPreview");
  const debug64 = document.getElementById("debug64");

  let srcEl = null;
  if (preview.style.display === "block" && preview.src) {
    srcEl = preview;
  } else if (videoStream) {
    srcEl = video;
  } else {
    return null;
  }

  // 1) Normalize to 256x256
  const SRC = 256;
  const tmp = document.createElement("canvas");
  const tctx = tmp.getContext("2d");
  tmp.width = SRC;
  tmp.height = SRC;
  tctx.drawImage(srcEl, 0, 0, SRC, SRC);

  const imgData = tctx.getImageData(0, 0, SRC, SRC);
  const rgba = imgData.data;

  // 2) Grayscale + stats
  const gray = new Float32Array(SRC * SRC);
  let minV = 255, maxV = 0;
  for (let i = 0, j = 0; i < rgba.length; i += 4, j++) {
    const g = (rgba[i] + rgba[i + 1] + rgba[i + 2]) / 3;
    gray[j] = g;
    if (g < minV) minV = g;
    if (g > maxV) maxV = g;
  }

  // If almost no contrast, bail out
  if (maxV - minV < 25) {
    return null;
  }

  // 3) Dot-friendly adaptive threshold
  // Take bright background from top 10% brightest pixels
  const sorted = Array.from(gray).sort((a, b) => a - b);
  const bg = sorted[Math.floor(sorted.length * 0.90)]; // 90th percentile
  let threshold = bg - 35; // keep pixels at least 35 darker than background

  // Clamp threshold so we don't kill subtle strokes
  if (threshold < minV + 5) threshold = minV + 5;
  if (threshold > bg - 5) threshold = bg - 5;

  const darkIdx = [];
  for (let i = 0; i < gray.length; i++) {
    if (gray[i] < threshold) darkIdx.push(i);
  }

  if (darkIdx.length < 40) {
    return null; // not enough ink
  }

  // 4) Bounding box of dark pixels
  let minX = SRC, minY = SRC, maxX = 0, maxY = 0;
  for (const idx of darkIdx) {
    const y = Math.floor(idx / SRC);
    const x = idx % SRC;
    if (x < minX) minX = x;
    if (x > maxX) maxX = x;
    if (y < minY) minY = y;
    if (y > maxY) maxY = y;
  }

  // 5) Pad and force square region
  const pad = 16;
  minX = Math.max(0, minX - pad);
  minY = Math.max(0, minY - pad);
  maxX = Math.min(SRC - 1, maxX + pad);
  maxY = Math.min(SRC - 1, maxY + pad);

  let w = maxX - minX + 1;
  let h = maxY - minY + 1;
  const side = Math.max(w, h);
  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;
  minX = Math.max(0, Math.floor(cx - side / 2));
  minY = Math.max(0, Math.floor(cy - side / 2));
  maxX = Math.min(SRC - 1, minX + side - 1);
  maxY = Math.min(SRC - 1, minY + side - 1);

  // 6) Draw into 64x64 white background
  const canvas = document.getElementById("hiddenCanvas");
  const ctx = canvas.getContext("2d");
  canvas.width = 64;
  canvas.height = 64;

  ctx.fillStyle = "#FFFFFF";
  ctx.fillRect(0, 0, 64, 64);
  ctx.drawImage(
    tmp,
    minX, minY, maxX - minX + 1, maxY - minY + 1,
    0, 0, 64, 64
  );

  // 7) Debug preview
  if (debug64) {
    const dbgCtx = debug64.getContext("2d");
    dbgCtx.imageSmoothingEnabled = false;
    dbgCtx.drawImage(canvas, 0, 0, 64, 64);
  }

  // 8) Return grayscale array
  const cropped = ctx.getImageData(0, 0, 64, 64);
  const data = cropped.data;
  const out = new Float32Array(64 * 64);
  for (let i = 0, j = 0; i < data.length; i += 4, j++) {
    out[j] = (data[i] + data[i + 1] + data[i + 2]) / 3;
  }
  return out;
}



  async function predict() {
    const status = document.getElementById("status");
    const resultEl = document.getElementById("resultChar");
    const errorBox = document.getElementById("errorBox");
    const confText = document.getElementById("confText");
    errorBox.textContent = "";
    confText.textContent = "";

    if (!session) {
      status.textContent = "Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ ØºÙŠØ± Ø¬Ø§Ù‡Ø² Ø¨Ø¹Ø¯.";
      return;
    }

    const gray = getCurrentFrameAs64Gray();
    if (!gray) {
      errorBox.textContent = "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø­Ø±Ù ÙˆØ§Ø¶Ø­ ÙÙŠ Ø§Ù„ØµÙˆØ±Ø©. Ø§Ø¬Ø¹Ù„ Ø­Ø±ÙÙ‹Ø§ ÙˆØ§Ø­Ø¯Ù‹Ø§ ÙƒØ¨ÙŠØ±Ù‹Ø§ ÙÙŠ Ø§Ù„Ù…Ù†ØªØµÙ Ø¨Ø®Ù„ÙÙŠØ© Ø¨ÙŠØ¶Ø§Ø¡.";
      status.textContent = "Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ¹Ø±Ù.";
      lastChar = null;
      resultEl.textContent = "-";
      return;
    }

    status.textContent = "Ø¬Ø§Ø±Ù Ø§Ù„ØªØ¹Ø±Ù‘Ù...";
    try {
      const inputData = new Float32Array(1 * 1 * 64 * 64);
      for (let i = 0; i < gray.length; i++) {
        inputData[i] = gray[i] / 255.0;
      }

      const tensor = new ort.Tensor("float32", inputData, [1, 1, 64, 64]);
      const outputs = await session.run({ input: tensor });
      const logits = outputs.logits.data;

      // softmax
      let maxLogit = -1e9;
      for (let i = 0; i < logits.length; i++) {
        if (logits[i] > maxLogit) maxLogit = logits[i];
      }
      let sumExp = 0;
      for (let i = 0; i < logits.length; i++) {
        sumExp += Math.exp(logits[i] - maxLogit);
      }

      let bestIdx = 0;
      let bestProb = 0;
      for (let i = 0; i < logits.length; i++) {
        const p = Math.exp(logits[i] - maxLogit) / sumExp;
        if (p > bestProb) {
          bestProb = p;
          bestIdx = i;
        }
      }

      const ch = labels[String(bestIdx)] ?? "?";
      const threshold = 0.75;

      if (ch === "?" || !isFinite(bestProb) || bestProb < threshold) {
        // Not confident â†’ don't trust
        lastChar = null;
        resultEl.textContent = "-";
        confText.textContent =
          `ØºÙŠØ± ÙˆØ§Ø«Ù‚ (${(bestProb * 100).toFixed(1)}Ùª) - Ø¹Ø¯Ù‘Ù„ Ø§Ù„Ø²Ø§ÙˆÙŠØ©ØŒ Ù‚Ø±Ù‘Ø¨ Ø§Ù„Ø­Ø±ÙØŒ ÙˆØªØ£ÙƒÙ‘Ø¯ Ù…Ù† Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©.`;
        status.textContent = "Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø­Ø±Ù";
      } else {
        lastChar = ch;
        resultEl.textContent = ch;
        confText.textContent = `Ø«Ù‚Ø©: ${(bestProb * 100).toFixed(1)}Ùª`;
        status.textContent = "ØªÙ… Ø§Ù„ØªØ¹Ø±Ù‘Ù âœ…";
      }
    } catch (err) {
      console.error(err);
      errorBox.textContent = "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ¹Ø±Ù‘Ù.";
      status.textContent = "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ¹Ø±Ù‘Ù.";
      lastChar = null;
      resultEl.textContent = "-";
    }
  }

  function playVoice() {
    const errorBox = document.getElementById("errorBox");
    errorBox.textContent = "";
    if (!lastChar) {
      errorBox.textContent = "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø­Ø±Ù Ù„Ù†Ø·Ù‚Ù‡.";
      return;
    }
    const src = charAudio[lastChar];
    if (!src) {
      errorBox.textContent = "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ù„Ù ØµÙˆØª Ù„Ù‡Ø°Ø§ Ø§Ù„Ø­Ø±Ù.";
      return;
    }
    audioEl.pause();
    audioEl.currentTime = 0;
    audioEl.src = src;
    audioEl.play().catch(err => {
      console.error(err);
      errorBox.textContent = "ØªØ¹Ø°Ù‘Ø± ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª. ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ØµÙˆØª ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­.";
    });
  }

  function copyChar() {
    if (!lastChar) return;
    navigator.clipboard.writeText(lastChar).catch(() => {});
  }

  document.getElementById("startCamBtn").onclick = startCamera;
  document.getElementById("captureBtn").onclick = predict;
  document.getElementById("resetViewBtn").onclick = resetView;
  document.getElementById("playVoiceBtn").onclick = playVoice;
  document.getElementById("copyBtn").onclick = copyChar;

  document.getElementById("fileInput").addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => setPreviewImage(ev.target.result);
    reader.readAsDataURL(file);
  });

  loadModel();
</script>
</body>
</html>
